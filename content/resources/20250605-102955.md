---
title: Haxoris Wiki
draft: false
date: 2024-05-01
tags:
  - SSRF
  - security
  - vulnerability
---

_Back to Website_

# Haxoris Wiki

[Print this book](https://haxoris.com/haxoris-wiki/print.html)

Server-Side Request Forgery (SSRF) happens when someone tricks a server into making requests to places it shouldn't. This can let attackers look at internal systems, use sensitive services, or get into unsafe internal applications that aren't meant for the public.

Many internal applications, databases, admin panels, and cloud services can only be reached from inside the network. But if an application has an SSRF problem, an attacker can use it like a secret tunnel to get past firewalls and access internal stuff, cloud services, and important infrastructure.

A bad application lets people grab external URLs but doesn't check them carefully:

```

GET /fetch?url=https://example.com

```

An attacker can look around the internal network by changing the URL to check local IP addresses:

```

GET /fetch?url=http://192.168.1.1

```

If the server says "OK," the attacker knows that something is running on 192.168.1.1.

Some companies keep internal admin panels, monitoring tools, or databases at private IP addresses (like 10.0.0.1, 192.168.1.1). If there's an SSRF problem, an attacker can get into these services.

**Example: Getting into an Internal System**

```

GET /fetch?url=http://10.0.0.5:8080

```

- If the system is running internally, the attacker might see the login screen.
- If no password is needed, the attacker might run commands on the internal system.

In cloud environments, SSRF can be used to check internal services, like:

- System API Server (https://10.0.0.1:6443)
- Tool API (http://localhost:2375)
- Cloud Info Service (http://169.254.169.254/latest/meta-data/)

**Example: Looking at System Information**

```

GET /fetch?url=https://10.0.0.1:6443/api/v1/namespaces/default/pods

```

If the System API is set up wrong, the attacker might find internal names and information.

Some websites only let certain IP addresses (like 127.0.0.1) use admin panels or internal services.

If SSRF is there, an attacker can make the server make a local request for them, getting around these rules:

```

GET /fetch?url=http://127.0.0.1/admin

```

If the website is set up wrong, the attacker can now use internal admin features from far away.

1. **Block Requests to Internal IP Addresses**
- Don't allow access to internal networks (127.0.0.1, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16).

- Example rule to stop requests:

     \`\`\`plaintext hljs

     if request.url contains "127.0.0.1" or "169.254.169.254" or matches "10.*" {
          block request;
     }

     \`\`\`
1. **Check and Limit Outbound Requests**
- Only allow URLs from trusted places instead of letting in any URL.

- Don't allow requests with IP addresses, localhost, or internal services.

- Example filter:

     \`\`\`regex hljs

     ^(https?://(www.)?trusted-domain.com/.*)$

     \`\`\`
1. **Use a Special Helper for Outbound Requests**
- Send all requests through a safe helper that only allows certain URLs.
- Don't allow direct requests to internal network stuff.
1. **Separate the Network**
- Stop web servers from directly getting into internal applications or cloud services.
- Use security groups and rules to control server-to-server communication.
1. **Turn Off Unneeded Internal Services**
- Close internal services (like systems, tools) that don't need to be open internally.
- Require passwords and IP whitelisting for internal websites.

[Reference](https://haxoris.com/)